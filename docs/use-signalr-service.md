# Use Azure SignalR Service

- [Use Azure SignalR Service](#use-azure-signalr-service)
  - [Provision an Azure SignalR Service instance](#provision-an-azure-signalr-service-instance)
  - [Run ASP.NET CORE SignalR](#run-aspnet-core-signalr)
    - [1. Install and Use Service SDK](#1-install-and-use-service-sdk)
    - [2. Configure Connection String](#2-configure-connection-string)
    - [3. Configure Service Options](#3-configure-service-options)
      - [`ConnectionCount`](#connectioncount)
      - [`AccessTokenLifetime`](#accesstokenlifetime)
      - [`AccessTokenAlgorithm`](#accesstokenalgorithm)
      - [`ApplicationName`](#applicationname)
      - [`ClaimProvider`](#claimprovider)
      - [`ServerStickyMode`](#serverstickymode)
      - [`GracefulShutdown`](#gracefulshutdown)
        - [Mode](#mode)
        - [Timeout](#timeout)
      - [`ServiceScaleTimeout`](#servicescaletimeout)
      - [`MaxPollIntervalInSeconds`](#maxpollintervalinseconds)
      - [Sample](#sample)
  - [Run ASP.NET SignalR](#run-aspnet-signalr)
    - [1. Install and Use Service SDK](#1-install-and-use-service-sdk-1)
    - [2. Configure Connection String](#2-configure-connection-string-1)
    - [3. Configure Service Options](#3-configure-service-options-1)
      - [`ConnectionCount`](#connectioncount-1)
      - [`AccessTokenLifetime`](#accesstokenlifetime-1)
      - [`AccessTokenAlgorithm`](#accesstokenalgorithm-1)
      - [`ClaimProvider`](#claimprovider-1)
      - [`ConnectionString`](#connectionstring)
      - [`ServerStickyMode`](#serverstickymode-1)
      - [`MaxPollIntervalInSeconds`](#maxpollintervalinseconds-1)
      - [Sample](#sample-1)
  - [Scale Out Application Server](#scale-out-application-server)

<a name="provision"></a>
## Provision an Azure SignalR Service instance

Go to [Azure Portal](https://portal.azure.com) to provision a SignalR service instance.

<a name="coresignalr"></a>
## Run ASP.NET CORE SignalR

<a name="use-sdk"></a>
### 1. Install and Use Service SDK
Run below command to install SignalR Service SDK to your ASP.NET Core project.

```bash
dotnet add package Microsoft.Azure.SignalR --version 1.0.*
```

In your `Startup` class, use SignalR Service SDK as the following code snippet.

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddSignalR()
            .AddAzureSignalR();
}

public void Configure(IApplicationBuilder app)
{
    app.UseAzureSignalR(routes =>
    {
        routes.MapHub<YourHubClass>("/path_for_your_hub");
    });
}
```

<a name="connection-string"></a>
### 2. Configure Connection String

There are two approaches to configure SignalR Service's connection string in your application.
- Set an environment variable with name `Azure:SignalR:ConnectionString` or `Azure__SignalR__ConnectionString`.
    - In Azure App Service, put it in application settings.
- Pass the connection string as a parameter of `AddAzureSignalR()` as below sample codes.

    ```csharp
    services.AddSignalR()
            .AddAzureSignalR(<replace with your connection string>);
    ```

    or 

    ```csharp
    services.AddSignalR()
            .AddAzureSignalR(options => options.ConnectionString = <replace with your connection string>);
    ```

<a name="service-options"></a>
### 3. Configure Service Options

There are a few options you can customize when using Azure SignalR Service SDK.

#### `ConnectionCount`
- Default value is `5`.
- This option controls the count of connections between application server and Azure SignalR Service.
The default value will be performant enough most of the time.
You can increase it for better performance if the total client count is too big.
For example, if you have 100,000 clients in total, the connection count can be increased to `10` or `15` for better throughput.

#### `AccessTokenLifetime`
- Default value is `1 hour`.
- This option controls the valid lifetime of the access token, which is generated by Service SDK for each client.
The access token is returned in the response to client's negotiate request.
- When `ServerSentEvent` or `LongPolling` is used as transport, client connection will be closed due to authentication failure after the expire time.
You can increase this value to avoid client disconnect.

#### `AccessTokenAlgorithm`
- Default value is `HS256`
- This option provides choice of [`SecurityAlgorithms`](https://github.com/AzureAD/azure-activedirectory-identitymodel-extensions-for-dotnet/blob/dev/src/Microsoft.IdentityModel.Tokens/SecurityAlgorithms.cs) when generate access token. Now supported optional values are `HS256` and `HS512`. Please note `HS512` is more secure but the generated token will be comparatively longer than that using `HS256`.

#### `ApplicationName`	
- Default value is `null`.	
- This option can be useful when you want to share the same Azure SignalR instance for different app servers containing the same hub names. If not set, all the connected app servers are considered to be instances of the same application.

#### `ClaimProvider`
- Default value is `null`.
- This option controls what claims you want to associate with the client connection.
It will be used when Service SDK generates access token for client in client's negotiate request.
By default, all claims from `HttpContext.User` of the negotiate request will be reserved.
They can be accessed at [`Hub.Context.User`](https://github.com/aspnet/SignalR/blob/release/2.2/src/Microsoft.AspNetCore.SignalR.Core/HubCallerContext.cs#L29).
- Normally you should leave this option as is. Make sure you understand what will happen before customizing it.

<a name="server-sticky-mode"></a>

#### `ServerStickyMode` 
- Default value is `Disabled`.
- This option specifies the mode for **server sticky**. When the client is routed to the server which it first negotiates with, we call it **server sticky**.
- In distributed scenarios, there can be multiple app servers connected to one Azure SignalR instance. As [internals of client connections](internal.md#client-connections) explains, client first negotiates with the app server, and then redirects to Azure SignalR to establish the persistent connection. Azure SignalR then finds one app server to serve the client, as [Transport Data between client and server](internal.md#transport-data-between-client-and-server) explains.
    - When `Disabled`, the client routes to a random app server. In general, app servers have balanced client connections with this mode. If your scenarios are *broadcast* or *group send*, use this default option is enough.
    - When `Preferred`, Azure SignalR tries to find the app server which the client first negotiates with in a way that no additional cost or global routing is needed. This one can be useful when your scenario is *send to connection*. *Send to connection* can have better performance and lower latency when the sender and the receiver are routed to the same app server.
    - When `Required`, Azure SignalR always tries to find the app server which the client first negotiates with. This options can be useful when some client context is fetched from `negotiate` step and stored in memory, and then to be used inside `Hub`s. However, this option may have performance drawbacks because it requires Azure SignalR to take additional efforts to find this particular app server globally, and to keep globally routing traffics between client and server.


#### `GracefulShutdown`

##### Mode

- Default value is `Off`
- This option specifies the behavior after the app server receives a CTRL+C (SIGINT).
- When set to `WaitForClientsClose`, instead of stopping the server immediately, we remove it from the ASRS to prevent new client connections from being assigned to this server.
- When set to `MigrateClients`, in addition to the steps we mentioned in `WaitForClientsClose`, we will try migrating client connections to another valid server at a proper time. 
  We could make sure the migration will only happen on the message boundaries, which means each of old/new servers will receive intact messages.
  `OnConnected` and `OnDisconnected` will be triggered when connections be migrated in/out, and a `IConnectionMigrationFeature` will be set to help you determine if the connection has been migrated.
  Please visit our [sample codes](https://github.com/Azure/azure-signalr/blob/dev/samples/ChatSample/ChatSample/Hub/Chat.cs) for detail usage.


##### Timeout

- Default value is `30 seconds`
- This option specifies the longest time in waiting for clients to be closed/migrated.


#### `ServiceScaleTimeout`

- Default value is `5 minutes`
- This option specifies the longest time in waiting for dynamic scaling service endpoints, that to affect online clients at minimum. Normally the dynamic scale between single app server and a service endpoint can be finished in seconds, while considering if you have multiple app servers and multiple service endpoints with network jitter and would like to ensure client stability, you can configure this value accordingly.


#### `MaxPollIntervalInSeconds`

- Default value is `5`
- This option defines the max poll interval allowed for `LongPolling` connections in Azure SignalR Service. If the next poll request does not come in within `MaxPollIntervalInSeconds`, Azure SignalR Service cleans up the client connection. Note that Azure SignalR Service will also clean up connections when cached waiting to write buffer size is greater than `1Mb` to ensure service performance.
- The value is limited to `[1, 300]`.

#### Sample
You can configure above options like the following sample code.

```csharp
services.AddSignalR()
        .AddAzureSignalR(options =>
            {
                options.ConnectionCount = 10;
                options.AccessTokenLifetime = TimeSpan.FromDays(1);
                options.ClaimsProvider = context => context.User.Claims;

                options.GracefulShutdown.Mode = GracefulShutdownMode.WaitForClientsClose;
                options.GracefulShutdown.Timeout = TimeSpan.FromSeconds(10);
            });
```

<a name="aspnetsignalr"></a>
## Run ASP.NET SignalR
> If it is your first time trying SignalR, we recommend you to use the ASP.NET Core SignalR, it is **simpler, more reliable, and easier to use**.

<a name="aspnetsignalr-use-sdk"></a>
### 1. Install and Use Service SDK
Install SignalR Service SDK to your ASP.NET project with **Package Manager Console**:

```powershell
Install-Package Microsoft.Azure.SignalR.AspNet
```

In your `Startup` class, use SignalR Service SDK as the following code snippet, replace `MapSignalR()` to `MapAzureSignalR({your_applicationName})`. Replace `{YourApplicationName}` to the name of your application, this is the unique name to distinguish this application with your other applications. You can use `this.GetType().FullName` as the value.

```csharp
public void Configuration(IAppBuilder app)
{
    app.MapAzureSignalR(this.GetType().FullName);
}
```

<a name="aspnetsignalr-connection-string"></a>
### 2. Configure Connection String
Set the connection string in the `web.config` file, to the `connectionStrings` section:
```xml
<configuration>
    <connectionStrings>
        <add name="Azure:SignalR:ConnectionString" connectionString="Endpoint=...;AccessKey=..."/>
    </connectionStrings>
    ...
</configuration>
```

<a name="aspnetsignalr-service-options"></a>
### 3. Configure Service Options

There are a few [options](https://github.com/Azure/azure-signalr/blob/dev/src/Microsoft.Azure.SignalR.AspNet/ServiceOptions.cs) you can customize when using Azure SignalR Service SDK.

#### `ConnectionCount`
- Default value is `5`.
- This option controls the count of connections per hub between application server and Azure SignalR Service.
The default value will be performant enough most of the time.
You can increase it for better performance if the total client count is too big.
For example, if you have 100,000 clients in total, the connection count can be increased to `10` or `15` for better throughput.

#### `AccessTokenLifetime`
- Default value is `1 hour`.
- This option controls the valid lifetime of the access token, which is generated by Service SDK for each client.
The access token is returned in the response to client's negotiate request.
- When `ServerSentEvent` or `LongPolling` is used as transport, client connection will be closed due to authentication failure after the expire time.
You can increase this value to avoid client disconnect.

#### `AccessTokenAlgorithm`
- Default value is `HS256`
- This option provides choice of [`SecurityAlgorithms`](https://github.com/AzureAD/azure-activedirectory-identitymodel-extensions-for-dotnet/blob/dev/src/Microsoft.IdentityModel.Tokens/SecurityAlgorithms.cs) when generate access token. Now supported optional values are `HS256` and `HS512`. Please note `HS512` is more secure but the generated token will be comparatively longer than that using `HS256`.

#### `ClaimProvider`
- Default value is `null`.
- This option controls what claims you want to associate with the client connection.
It will be used when Service SDK generates access token for client in client's negotiate request.
By default, all claims from `IOwinContext.Authentication.User` of the negotiate request will be reserved.
- Normally you should leave this option as is. Make sure you understand what will happen before customizing it.

#### `ConnectionString`
- Default value is the `Azure:SignalR:ConnectionString` `connectionString` or `appSetting` in `web.config` file.
- It can be reconfigured, but please make sure the value is **NOT** hard coded.

#### `ServerStickyMode`
- Default value is `Disabled`.
- Refer to [ServerStickyMode](#server-sticky-mode) for details.

#### `MaxPollIntervalInSeconds`
- Default value is `5`
- This option defines the max poll interval allowed for `LongPolling` connections in Azure SignalR Service. If the next poll request does not come in within `MaxPollIntervalInSeconds`, Azure SignalR Service cleans up the client connection. Note that Azure SignalR Service will also clean up connections when cached waiting to write buffer size is greater than `1Mb` to ensure service performance.
- The value is limited to `[1, 300]`.

#### Sample
You can configure above options like the following sample code.

```csharp
app.Map("/signalr",subApp => subApp.RunAzureSignalR(this.GetType().FullName, new HubConfiguration(), options =>
{
    options.ConnectionCount = 1;
    options.AccessTokenLifetime = TimeSpan.FromDays(1);
    options.ClaimProvider = context => context.Authentication?.User.Claims;
}));
```

<a name="scaleout"></a>
## Scale Out Application Server

With Azure SignalR Service, persistent connections are offloaded from application server.
It only has to take care of business logics in your hub classes.
But you still need to scale out application servers for better performance when handling massive client connections.
Below are a few tips for scaling out application servers.
- Multiple application servers can connect to the same Azure SignalR Service instance.
- As long as name of the hub class is the same, connections from different application servers are grouped in the same hub.
- Each client connection will only be created in **one** of the application servers, and messages from that client will only be sent to the same application server.
- If you want to access client information globally (from all application servers), you have to use some storage to save client information from all application servers.
