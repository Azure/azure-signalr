# Use Azure SignalR Service

- [Provision a Service Instance](#provision)
- [Install and Use Service SDK](#use-sdk)
- [Configure Connection String](#connection-string)
- [Configure Service Options](#service-options)
- [Scale Out Application Server](#scaleout)

## Provision an Azure SignalR Service instance

Go to [Azure Portal](https://portal.azure.com) to provision a SignalR service instance.

## Install and Use Service SDK

Run below command to install SignalR Service SDK to your ASP.NET Core project.

```bash
dotnet add package Microsoft.Azure.SignalR --version 1.0.*
```

In your `Startup` class, use SignalR Service SDK as the following code snippet.

```csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddSignalR()
            .AddAzureSignalR();
}

public void Configure(IApplicationBuilder app)
{
    app.UseAzureSignalR(routes =>
    {
        routes.MapHub<YourHubClass>("/path_for_your_hub");
    });
}
```

## Configure Connection String

There are two approaches to configure SignalR Service's connection string in your application.
- Set an environment variable with name `Azure:SignalR:ConnectionString` or `Azure__SignalR__ConnectionString`.
    - In Azure App Service, put it in application settings.
- Pass the connection string as a parameter of `AddAzureSignalR()` as below sample codes.

    ```csharp
    services.AddSignalR()
            .AddAzureSignalR(<replace with your connection string>);
    ```

    or 

    ```csharp
    services.AddSignalR()
            .AddAzureSignalR(options => options.ConnectionString = <replace with your connection string>);
    ```

## Configure Service Options

There are a few options you can customize when using Azure SignalR Service SDK.

### `ConnectionCount`
- Default value is `5`.
- This option controls the count of connections between application server and Azure SignalR Service.
The default value will be performant enough most of the time.
You can increase it for better performance if the total client count is too big.
For example, if you have 100,000 clients in total, the connection count can be increased to `10` or `15` for better throughput.

### `AccessTokenLifetime`
- Default value is `1 hour`.
- This option controls the valid lifetime of the access token, which is generated by Service SDK for each client.
The access token is returned in the response to client's negotiate request.
- When `ServerSentEvent` or `LongPolling` is used as transport, client connection will be closed due to authentication failure after the expire time.
You can increase this value to avoid client disconnect.

### `ClaimProvider`
- Default value is `null`.
- This option controls what claims you want to associate with the client connection.
It will be used when Service SDK generates access token for client in client's negotiate request.
By default, all claims from `HttpContext.User` of the negotiate request will be reserved.
They can be accessed at [`Hub.Context.User`](https://github.com/aspnet/SignalR/blob/release/2.2/src/Microsoft.AspNetCore.SignalR.Core/HubCallerContext.cs#L29).
- Normally you should leave this option as is. Make sure you understand what will happen before customizing it.

### Sample
You can configure above options like the following sample code.

```csharp
services.AddSignalR()
        .AddAzureSignalR(options =>
            {
                options.ConnectionCount = 10;
                options.AccessTokenLifetime = TimeSpan.FromDays(1);
                options.ClaimsProvider = context => context.User.Claims;
            });
```

## Scale Out Application Server

With Azure SignalR Service, persistent connections are offloaded from application server.
It only has to take care of business logics in your hub classes.
But you still need to scale out application servers for better performance when handling massive client connections.
Below are a few tips for scaling out application servers.
- Multiple application servers can connect to the same Azure SignalR Service instance.
- As long as name of the hub class is the same, connections from different application servers are grouped in the same hub.
- Each client connection will only be created in **one** of the application servers, and messages from that client will only be sent to the same application server.
- If you want to access client information globally (from all application servers), you have to use some storage to save client information from all application servers.
